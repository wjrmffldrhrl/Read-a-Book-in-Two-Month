# 메세지 배송의 트레이드 오프

## 메세지 브로커
메세지 베송에 의해 보내진 데이터를 분산 스토ㅓ리지에 저장할 때는 주의가 필요하다.  
- 쓰기의 빈도가 증가함에 따라 디스크 성능의 한계에 도달해 더 쓸 수 없게 될 우려가 있기 때문이다.
- 외부에서 보내오는 메세지의 양을 제어할 수 없기 때문에 급격한 데이터양 증가에 대응하는 것은 쉬운 일이 아니다.  

대량의 메세지를 안정적으로 받기 위해서는 빈번한 쓰기에도 견딜 수 있도록 성능이 매우 높고 필요에 따라 성능을 얼마든지 올릴 수 있는 스토리지가 필요하다.  
- 빅데이터의 메세지 배송 시스템에서는 데이터를 일시적으로 축적하는 중산층인 **메세지 브로커(message broker)**가 설치된다.  

### 푸쉬 형과 풀 형
- 송신 측의 제어로 데이터를 보내는 방식 : 푸쉬
- 수신 측의 주도로 데이터를 가져오는 것 : 풀  

메세지 브로커에 데이터를 넣는 것을 **생산자(producer)**, 꺼내오는 것을 **소비자(consumer)**라고 한다.  
메세지 브로커는 높은 빈도로 데이터를 쓰는 것에 최적화되어 있으며, 여러 대의 노드에 부하 분산함으로써 성능을 끌어 올릴 수 있는 뛰어난 확장성을 구현하고 있다. 

## 메세지 배송을 확실하게 실시하는 것은 어렵다.
성능 문제 외에도 피할 수 없는 것이 **신뢰성(reliability)**의 문제다.  
- 특히, 모바일 회선과 같은 신뢰성이 낮은 네트워크에서는 반드시 메세지의 중복이나 누락이 발생한다.   

대부분의 경우는 아래 중 하나를 보장하도록 설계 된다.
- at most once
  - 메세지는 한 번만 전송된다.
  - 도중에 전송에 실패해서 사라질 가능성이 있다.
- exactly once
  - 메세지는 손실되거나 중복 없이 한 번만 전달된다.
- at least once
  - 메세지는 확실히 전달된다. 
  - 단, 같은 것이 여러 번 전달될 가능성이 있다.


### at most once
이 경우, 무슨 일이 일어나도 절대로 메세지를 다시 보내지 않는다.  
- 그러나 대개는 데이터의 결손을 피하고자 **재전송(retransmission)**이 이루어진다.  
- 재전송 하는 시스템에서는 at most once를 보장하는 것이 어렵다.  

### exactly once
네트워크상에서 분단된 두 개의 노드가 있는 경우에 양쪽의 통신 내용을 보장하려면 그 사이에 중계하는 **코디네이터(cordinator)**의 존재가 필수적이다.  

여기에는 두 가지 문제가 있다.
1. 분산 시스템에서는 코디네이터가 항상 존재한다고 가정할 수 없다.
  - 코디네이터와의 통신이 끊기는 경우가 있다.
  - 코디네이터 자신이 정지될 수 있다.  
  - 그때마다 시스템을 멈출 수 없기 때문에, 코디네이터의 부재의 경우에 어떻게 할 것인지 합의를 하게 된다.
2. 코디네이터의 판단에만 따르고 있으면 시간이 너무 소요된다.


### at least once
코디네이터에서 발생할 수 있는 두 가지 문제로 인해 대부분의 메세지 배송 시스템에서는 코디네이터를 도입하지 않고 at leas once, 즉 메세지가 중복될 가능성을 고려하여 시스템을 구축한다.  

중복제거는 사용자에게 맡긴다.  
예를 들어, TCP/IP에 의한 네트워크 통신에서 TCP 통신의 모든 패킷에 그것을 식별하는 시퀀스 번호를 포함하여 중복을 제거한다.  

