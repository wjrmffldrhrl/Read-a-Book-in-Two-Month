# 워크플로 관리
정해진 업무를 원활하게 진행하기 위한 구조를 일반적으로 **워크플로 관리(workflow management)**라고 한다.

### 워크플로 관리 도구
워크플로 관리 도구의 주요 역할은 아래와 같다.
- 정기적으로 태스크를 실행
- 비정상적인 상태를 감지하고 해결을 도움

주로 사용되는 것은 아래의 5개가 있다.
- Airflow : 스크립트 형
- Azkaban : 선언형
- Digdag : 선언형
- Luigi : 스크립트 형
- Oozie : 선언형

### 워크플로 관리 도구와 태스크
데이터 파이프라인의 실행 과정에서는 데이터를 잇달아 이동하면서 정해진 처리를 반복한다.
- 이때 실행되는 개별 처리를 **태스크(task)**라고 부른다.  

### 기본 기능과 빅데이터에서 요구되는 기능
워크플로 관리를 위해 전용 도구를 사용하는 이유는 태스크 실행에 실패할 수 있기 때문이다.
- 데이터 파이프라인이 복잡해지거나, 태스크의 수가 증가하면 실패한 대스크를 다시 실행하는 일 또한 점차 어려워진다.
- 그래서, 워크플로 관리 도구는 주로 다음과 같은 기능을 제공한다.
  - 태스크를 정기적인 스캐줄로 실행하고 그 결과 통지하기
  - 태스크 간의 의존 관계를 정하고, 정해진 순서대로 빠짐없이 실행하기
  - 태스크의 실행 결과를 보관하고, 오류 발생 시에는 재실행할 수 있도록 하기

## 오류로부터 복구 방법 먼저 생각하기
데이터 파이프라인을 매일 동작시키다 보면, 뭔가 예기치 못한 오류가 분명 발생한다.  
이것을 대응하는데 시간을 허비하면 피해가 커진다.  
- 예를 들어 1일의 액세스 로그를 집계하는데 4시간의 배치 처리를 동작시킨다고 할 때
  - 만약 실패하여 다시 4시간에 걸쳐 재시도한다면, 그날의 워크플로에 큰 지연이 발생한다.
  - 후속의 태스크 중에는 예정된 시간까지 끝내지 않으면 새로운 문제를 일으키는 것이 있을지도 모른다.
  - 그러면 하나의 실패가 연쇄적으로 확대돼서 결과적으로는 모든 태스크를 처음부터 다시 시작해야 하므로 하루를 낭비하게 된다.  


빅데이터를 취급하고 있으면 다양한 오류가 발생한다.
- 네트워크의 일시적인 장애
- 하드웨어 장애
- 스토리지의 용량 부족
- 쿼리 증가에 따른 성능 부족

이러한 문제가 발생할 가능성을 고려하여 오류 발생 시의 대처 방법을 결정해두는 것이 중요하다.  

### 복구와 플로우의 재실행
오류에는 수많은 가능성이 있으므로 기본적으로 워크플로 관리에서는 오류로부터 자동 회복할 수 있다는 점은 고려하지 않는다.
- 대신에 수작업에 의한 **복구(recovery)**를 전제한 태스크를 설계한다.
  - 실패한 태스크는 모두 기록하여 그것을 나중에 재실행할 수 있도록 한다.  


워크플로 관리 도구에 의해 실행되는 일련의 태스크를 **플로우(flow)**라고 한다.
- 각 플로우에는 실행 시에 고정 파라미터가 부여되어 있다.
  - 일별 배치 처리라 하면, 특정 날짜가 파라미터가 된다.
  - 동일 플로우에 동일 파라미터를 건네면, 완전히 동일한 태스크가 실행되도록 한다.
  - 플로우가 도중에 실패해도 나중에 동일 파라미터로 재실행이 가능하다. -> 이것이 **복구의 기초다.**



### 재시도
여러 번 발생하는 오류에 대해서는 되도록 자동화하여 수작업 없이 복구하고 싶을 것이다.  
- 간단한 것은 태스크 단위의 자동적인 **재시도(retry)**, 즉 단순한 재실행이다.
- 곧바로 재시도해도 실패를 반복하는 일이 많기 때문에, 재시도 간격을 조금 두면 성공할 수 있다.

태스크를 재시도하는 것은 간단하지만, 재시도 횟수에는 주의가 필요하다.
- 재시도가 적으면, 장애로부터 복구하기 전에 재시도가 종료해 태스크 실행에 실패한다.
- 반대로 재시도가 너무 많으면, 태스크가 실패하지 않은 것처럼 되기 때문에 중대한 문제가 발생해도 눈치채지 못한다.

### 백필
실패한 플로우를 복구하는 다른 하나의 수단은 플로우 전체를 처음부터 다시 실행하는 것이다.
- 이를 위해 이용할 수 있는 것이 **백필(backfill)**의 기능이다.  

백필이란 파라미터에 포함된 일시를 순서대로 바꿔가면서 일정 기간의 플로우를 연속해서 실행하는 구조다.  

아래와 같은 경우에 실행한다.
- 태스크의 실패가 며칠 동안이나 계속된 후에 이를 모두 모아서 실행하고 싶을때,
- 새롭게 만든 워크플로를 과거로 거슬러 올라가 실행하고 싶은 경우에

## 멱등한 조작으로 태스크를 기술하기
복구의 전제로써 기억해야 할 것은 재실행의 안전성이다.
- 태스크를 도중까지 실행하다가 실패했을 때 그 도중 경과가 사라지지 않고 남아있으면, 태스크의 재실행에 의해 데이터가 혼재하는 문제가 발생한다.  
- 각 태스크는 원칙적으로 마지막까지 성공하거나 실패하면 아무것도 남지 않음 이 둘 중 하나만 존재해야 한다.
  - 도중까지 성공이라는 어정쩡한 상황은 허가하지 않는다.

### 원자성 조작
만약 한 태스크에서 INSERT 문을 2회 실행할 때, 첫 번째의 INSERT가 종료한 시점에 오류가 발생하고 태스크가 재실행 된다면 동일한 데이터가 다시 쓰이게 될 수 있다.  

이 문제를 회피하는 방법은, 각 태스크가 시스템에 변경을 가하는 것을 한 번만 할 수 있도록 하는 것이다.  
- 트랜잭션 처리에 대응한 데이터베이스라면, 여러 번의 쓰기를 한 번의 트랜잭션으로 실행한다.
- 그렇지 않다면, 쓰기가 필요한 수만큼 태스크를 나눈다.

이를 일반적으로 **원자성 조작(atomic operation)**이라고 부른다.

### 멱등성 조작  
멱등성이란, 동일한 태스크를 여러 번 실행해도 동일한 결과가 되도록 하는 것이다.  
- SQL의 경우 테이블을 삭제한 후에 다시 만들기가 멱등성 조작의 예다.

일반적으로 워크플로의 각 태스크는 **추가(append)** 또는 **치환(replace)** 중 하나를 실시한다.
- 분산 스토리지에 파일을 업로드한다면, 매번 새로운 파일명을 만들 경우는 데이터를 추가하는 것이고, 동일 파일명으로 덮어쓰기 하면 치환하는 것이다.  
- 추가를 반복하면 데이터가 중복되지만, 치환은 반복해도 결과가 변하지 않으므로 멱등하다고 할 수 있다.


### 멱등한 추가
현실에서는 항상 멱등한 태스크를 구현할 수 없다.
- 예를 들어 SQL에 의한 테이블 쓰기에는 그 날의 데이터만을 INSERT 문으로 기존 테이블에 추가하고 싶을 때도 있다.
- 이 경우 해당 태스크는 원자성을 가지고 있지만, 그냥 그대로는 멱등하지 않다.  

과거의 모든 데이터를 치환하면 멱등하긴 하지만 부하가 커진다.  

INSERT 앞에서 기존의 데잍러르 삭제하면 간접적으로 데이터를 치환하게 되지만, 일반적으로 테이블로부터 일부의 데이터만을 삭제하는 것은 비효율적이다.  

이것을 해결하기 위해 **테이블 파티셔닝**을 사용한다.  



## 워크플로 자체를 멱등으로 하기
데이터 파이프라인을 안정적으로 운용하기 위해서는 거기에 포함된 태스크나 플로우를 가능한 한 멱등으로 해야한다.  
- 데이터 수집 파이프라인에서는 테이블 파티셔닝을 도입함으로써 파티션 단위의 치환이 가능하다.
- 벌크 형의 데이터 전송에서는 워크플로 관리 도구에서 날자와 시간을 파라미터로 전달함으로써 치환 형의 태스크를 구현할 수 있다.


